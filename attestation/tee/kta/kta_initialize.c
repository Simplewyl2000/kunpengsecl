/*
kunpengsecl licensed under the Mulan PSL v2.
You can use this software according to the terms and conditions of
the Mulan PSL v2. You may obtain a copy of Mulan PSL v2 at:
    http://license.coscl.org.cn/MulanPSL2
THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
See the Mulan PSL v2 for more details.

Author: leezhenxiang
Create: 2022-11-04
Description: initialize module in kta.
	1. 2022-11-04	leezhenxiang
		define the structures.
    2. 2022-11-18   waterh2o
        redefine some interface
    3. 2022-11-25   waterh2o
        Function implementation
*/

#include <kta_common.h>
#include <tee_mem_mgmt_api.h>
#include <tee_trusted_storage_api.h>
#include <tee_crypto_api.h>
#include <tee_crypto_api.h>
#include <string.h>
#include <securec.h>

extern Cache cache;
extern CmdQueue cmdqueue;
extern ReplyQueue replyqueue;

// TEE_Result GenerateKeyPair(uint32_t keytype, uint32_t keysize, void *pubkey, void *privkey) {
//     //todo: generate a pair of key according to keytype and keysize

//     //input: keytype, keysize
//     //output: pubkey, privkey

//     /*
//     TEE_TYPE_RSA_KEYPAIR        = 0xA1000030,
//     TEE_TYPE_DSA_KEYPAIR        = 0xA1000031,
//     TEE_TYPE_DH_KEYPAIR         = 0xA1000032,
//     TEE_TYPE_ECDSA_KEYPAIR      = 0xA1000041,
//     TEE_TYPE_ECDH_KEYPAIR       = 0xA1000042,
//     TEE_TYPE_ED25519_KEYPAIR    = 0xA1000043,
//     TEE_TYPE_X25519_KEYPAIR     = 0xA1000044,
//     TEE_TYPE_SM2_DSA_KEYPAIR    = 0xA1000045,
//     TEE_TYPE_SM2_KEP_KEYPAIR    = 0xA1000046,
//     TEE_TYPE_SM2_PKE_KEYPAIR    = 0xA1000047,
//     */
// }

// TEE_Result SignPubKey(void *pubkey, void *signedpubkey) {
//     //todo: sign the public key generated by function GenerateKeyPair with TEE key

//     //input: pubkey
//     //output: signedpubkey
// }

/*
TEE_Result saveKeyPair(char *keyname, uint8_t *keyvalue, size_t keysize, uint32_t keytype) {
    //todo: save a certain kind ok key into the physical media
    //TEE_TYPE_RSA_PUBLIC_KEY
    //TEE_TYPE_RSA_KEYPAIR
    uint32_t storageID = TEE_OBJECT_STORAGE_PRIVATE;
    TEE_ObjectHandle transient_key = NULL;
    TEE_ObjectHandle persistent_key = NULL;
    TEE_Result ret;
    uint32_t w_flags = TEE_DATA_FLAG_ACCESS_WRITE;
    //uint32_t r_flags = TEE_DATA_FLAG_ACCESS_READ;
    void *objectID = keyname;
    //void *key = NULL;
    ret = TEE_AllocateTransientObject(keytype, 0x00001000, (&transient_key));
    transient_key->Attribute->content.ref.length = keysize;
    transient_key->Attribute->content.ref.buffer = keyvalue;
    
    ret = TEE_CreatePersistentObject(storageID, objectID, strlen(objectID), w_flags, transient_key, NULL, keysize+1,(&persistent_key));
    if (ret != TEE_SUCCESS) {
        tloge("Failed to create object:ret = 0x%x\n", ret);
        TEE_FreeTransientObject(transient_key);
        return ret;
    }
    TEE_CloseObject(persistent_key);
    TEE_FreeTransientObject(transient_key);
    return TEE_SUCCESS;
}
*/
TEE_Result saveKeyandCert(char *name, uint8_t *value, size_t size) {
    //todo: save a certain kind ok key into the physical media
    uint32_t storageID = TEE_OBJECT_STORAGE_PRIVATE;
    uint32_t w_flags = TEE_DATA_FLAG_ACCESS_WRITE;
    void *create_objectID = name;
    TEE_ObjectHandle persistent_data = NULL;
    TEE_Result ret;
    uint8_t *write_buffer = value;
    ret = TEE_CreatePersistentObject(storageID, create_objectID, strlen(create_objectID), w_flags, TEE_HANDLE_NULL, NULL, 0, (&persistent_data));
    if (ret != TEE_SUCCESS) {
        tloge("Failed to create file: ret = 0x%x\n", ret);
        return ret;
    }

    ret = TEE_WriteObjectData(persistent_data, write_buffer, size);
    if (ret != TEE_SUCCESS) {
        tloge("Failed to write file: ret = 0x%x\n", ret);
        /* 打开或创建文件之后异常分支需要关闭文件，否则会产生内存泄漏 */
        TEE_CloseObject(persistent_data);
        return ret;
    }
    TEE_CloseObject(persistent_data);
    return TEE_SUCCESS;
}

TEE_Result restoreKeyandCert(char *name, uint8_t *buffer, size_t *buf_len) {
    TEE_Result ret;
    uint32_t storageID = TEE_OBJECT_STORAGE_PRIVATE;
    uint32_t r_flags = TEE_DATA_FLAG_ACCESS_READ;
    void *create_objectID = name;
    TEE_ObjectHandle persistent_data = NULL;
    uint32_t pos = 0;
    uint32_t len = 0;
    char *read_buffer = NULL;
    uint32_t count = 0;
    ret = TEE_OpenPersistentObject(storageID, create_objectID, strlen(create_objectID),r_flags, (&persistent_data));
    if (ret != TEE_SUCCESS) {
        tloge("Failed to open file:ret = 0x%x\n", ret);
        return ret;
    }

    ret = TEE_InfoObjectData(persistent_data, &pos, &len);
    if (ret != TEE_SUCCESS) {
        tloge("Failed to open file:ret = 0x%x\n", ret);
        TEE_CloseObject(persistent_data);
        return ret;
    }

    read_buffer = TEE_Malloc(len + 1, 0);
    if (read_buffer == NULL) {
        tloge("Failed to open file:ret = 0x%x\n", ret);
        TEE_CloseObject(persistent_data);
        return ret;
    }

    /* 读取已存入的数据 */
    ret = TEE_ReadObjectData(persistent_data, read_buffer, len, &count);
    if (ret != TEE_SUCCESS) {
        TEE_CloseObject(persistent_data);
        TEE_Free(read_buffer);
        return ret;
    }
    *buf_len = len;
    int32_t rc = memmove_s(buffer, len, read_buffer, len);
    if (rc != 0) {
        TEE_CloseObject(persistent_data);
        TEE_Free(read_buffer);
        return TEE_ERROR_SECURITY;
    }
    TEE_CloseObject(persistent_data);
    TEE_Free(read_buffer);
    return TEE_SUCCESS;
}

TEE_Result initStructure(){
    //init cache
    cache.head = -1;
    cache.tail = -1;
    for(int i=0;i<MAX_TA_NUM;i++){
        cache.ta[i].next = -1;
        cache.ta[i].head = -1;
        cache.ta[i].tail = -1;
        for(int j=0;j<MAX_KEY_NUM;j++){
            cache.ta[i].key[j].next = -1;
        }
    }
    //init cmdqueue
    cmdqueue.head = 0;
    cmdqueue.tail = 0;
    //init replyqueue
    replyqueue.head = 0;
    replyqueue.tail = 0;
    return TEE_SUCCESS;
}

TEE_Result reset(char *name){
    TEE_Result ret;
    uint32_t storageID = TEE_OBJECT_STORAGE_PRIVATE;
    uint32_t r_flags = TEE_DATA_FLAG_ACCESS_READ;
    TEE_ObjectHandle persistent_data = NULL;
    ret = TEE_OpenPersistentObject(storageID, name, strlen(name),
    r_flags | TEE_DATA_FLAG_ACCESS_WRITE_META, (&persistent_data));
    if (ret != TEE_SUCCESS) {
        tloge("Failed to execute TEE_OpenPersistentObject:ret = %x\n", ret);
        return ret;
    }
    TEE_CloseAndDeletePersistentObject(persistent_data);
    return TEE_SUCCESS;
}

TEE_Result Reset_All(){
    TEE_Result ret;
    ret = reset("sec_storage_data/ktacert.txt");
    if (ret != TEE_SUCCESS) {
        tloge("Failed to reset ktacert\n", ret);
        return ret;
    }
    reset("sec_storage_data/kcmpub");
    if (ret != TEE_SUCCESS) {
        tloge("Failed to reset kcmpub\n", ret);
        return ret;
    }
    reset("sec_storage_data/ktakey");
    if (ret != TEE_SUCCESS) {
        tloge("Failed to reset ktakey\n", ret);
        return ret;
    }
    return TEE_SUCCESS;
}
